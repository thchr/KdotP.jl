var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from KdotP, that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"CurrentModule = KdotP","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"Modules = [KdotP]\nPrivate = true\nPublic  = false\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"internal-api/#KdotP.minimal_generators_indices-Tuple{Any}","page":"Internal API","title":"KdotP.minimal_generators_indices","text":"Returns a set of indices into group g which generates the group g, i.e., such that\n\nidxs = minimal_generators_indices(g; cntr)\ngâ€² = generate(g[idxs]; cntr)\n\nwhere gâ€² ~ g (but may differ by trivial reciprocal lattice vectors in some operations).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#KdotP.poormans_sparsification-Tuple{Any}","page":"Internal API","title":"KdotP.poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\n\n\n\n\n","category":"method"},{"location":"","page":"API","title":"API","text":"CurrentModule = KdotP","category":"page"},{"location":"#KdotP.jl","page":"API","title":"KdotP.jl","text":"","category":"section"},{"location":"#API","page":"API","title":"API","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"kdotp\nMonomial\nMonomialBasis\nMonomialHamiltonian\ndegree\nchern_2x2_hamiltonian","category":"page"},{"location":"#KdotP.kdotp","page":"API","title":"KdotP.kdotp","text":"kdotp(lgir::LGIrrep,\n      Î±Î²Î³=nothing;\n      timereversal::Bool = true,\n      degree::Union{Integer, Nothing} = nothing)  -->  Vector{MonomialHamiltonian}\n\nReturn a basis for the allowed kâ‹…p Hamiltonians of a small irrep lgir up to linear degree in momentum.\n\nInput arguments\n\nlgir: a small irrep of a little group, provided as an instance of the type LGIrrep. Tables of LGIrreps are accessible from the lgirreps function of Crystalline.jl package.\nÎ±Î²Î³: if the little group associated with lgir has free parameters, i.e., if the k-point is parametrized by free parameters (Î±, Î², Î³), these parameters may be set via Î±Î²Î³ = [Î±, Î², Î³]. If Î±Î²Î³ = nothing (default), lgir is implicitly evaluated at Î±Î²Î³ = [0, 0, 0].\n\nKeyword arguments\n\ntimereversal (keyword argument): if true (default), time-reversal invariance is imposed on the kâ‹…p expansion. If lgir is a corepresentation (i.e., a \"glued-up\" irrep), timereversal must be set to true; conversely, if lgir is a pseudoreal or complex irrep that would otherwise pair up under time-reversal, timereversal must be set to false.\ndegree: if provided, monomial terms up to degree will be considered; if degree = nothing (default), the search over monomial terms will terminate after finding the lowest-degree allowed (i.e., nonvanishing) monomial term.\n\nOutput\n\nHs: a vector of MonomialHamiltonian, with each element Há´¹ containing the allowable terms of a kâ‹…p expansion of incrementing monomial degree degree(Há´¹) consistent with the transformation properties dictated by lgir.\nEach such allowable term Há´¹ = H^M(mathbfk) is an expansion in a set of basis elements H_a^M(mathbfk):\nH^M(mathbfk) = sum_a q_a H_a^M(mathbfk)\nwhere q_a are free coefficients and H_a^M(mathbfk) are the basis elements of the degree M = degree(Há´¹) monomial terms of the kâ‹…p Hamiltonian.\nThe coordinates of the kâ‹…p model are displayed as x, y, & z for brevity; in practice, they refer to the relative coordinates kâ‚, kâ‚‚, & kâ‚ƒ, respectively, for the k-point k = âˆ‘áµ¢káµ¢Gáµ¢, with Gáµ¢ denoting a reciprocal basis vector. This reciprocal basis is implicitly specified through the choice of coordinates used in  specifying the little group operations associated with lgir.\nTo evaluate Há´¹ for a specific set of expansion vectors at a particular k-point (measured relative to the k-point in lgir, and, as described above, assumed referred to the basis system assumed in lgir) and for a particular set of expansion coefficients qs = q_1 q_2 ldots q_N, Há´¹ can be  called as a functor using the syntax  Há´¹(k, qs).\n\n\n\n\n\n","category":"function"},{"location":"#KdotP.Monomial","page":"API","title":"KdotP.Monomial","text":"Monomial{D}(ps::NTuple{D, Int})\nMonomial(p1, p2, ..., pD)\n\nDefine the D-dimensional monomial \n\nx^M = x_1^p_1 cdots x_i^p_i cdots x_D^p_D = prod_i^D x_i^p_i\n\nwith non-negative integer powers p_i = ps[i].  The degree of the monomial M is prod_i p_i (see degree(::Monomial)).\n\nA Monomial xá´¹ behaves as a functor and can be evaluated at a given position xs = [xâ‚, â€¦, xáµ¢, â€¦, x_D] via xá´¹(xs).\n\nExamples\n\njulia> xá´¹Â¹ = Monomial(1,2,3)\nxâ‚xâ‚‚Â²xâ‚ƒÂ³\n\njulia> vÂ¹ = xá´¹Â¹([1,2,3]) # = 1 * 2^2 * 3^3\n108\n\njulia> xá´¹Â² = Monomial(3,1,0,2)\nxâ‚Â³xâ‚‚xâ‚„Â²\n\njulia> vÂ² = xá´¹Â²([1,2,3,5]) # = 1^3 * 2^1 * 3^0 * 5^2\n50\n\n\n\n\n\n","category":"type"},{"location":"#KdotP.MonomialBasis","page":"API","title":"KdotP.MonomialBasis","text":"MonomialBasis{D} <: AbstractVector{Monomial}\n\n- `M :: Int` (degree of monomial basis elements)\n- `psv :: Vector{Monomomial{D}` (basis elements)\n\nA wrapper around a vector of Monomial{D}, the elements of which constitute a monomial basis for polynomials of degree M in D dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#KdotP.MonomialHamiltonian","page":"API","title":"KdotP.MonomialHamiltonian","text":"MonomialHamiltonian{D}\n\nFields\n\nhs   :: Vector{Hermitian{ComplexF64, Matrix{ComplexF64}}}\nbá´¹   :: MonomialBasis{D}\ncs   :: Vector{Vector{Vector{Float64}}}\n\nDescription\n\nA MonomialHamiltonian Há´¹ parameterizes the form of a kâ‹…p Hamiltonian of monomial k-dependence of degree M = degree(Há´¹):\n\nH^M(mathbfk) = sum_a q_a^M H_a^M(mathbfk)\n\nwhere q_a^M are free (expansion) coefficients and H_a^M(mathbfk) are the basis elements of the allowed kâ‹…p Hamiltonian terms of monomial degree M.\n\nA MonomialHamiltonian contains the basis elements H_a(mathbfk), allowing only monomial terms of degree M in momentum. In particular, the data structure for the fixed, k-dependent matrices H_a(mathbrmk) are of the form:\n\nH_a(mathbfk) = sum_n H.hs[n] sum_j H.cs[a][j][n] k_j^M\n\nwith H denoting an instance of the type MonomialHamiltonian and k_j^M denoting a basis element of the monomials of degree M (see also KdotP.Monomial and KdotP.MonomialBasis).\n\n\n\n\n\n","category":"type"},{"location":"#KdotP.degree","page":"API","title":"KdotP.degree","text":"degree(H::Monomial{D}) --> Int\n\nFor a monomial \n\nx^M = x_1^p_1 cdots x_i^p_i cdots x_D^p_D = prod_i^D x_i^p_i\n\nreturn its degree M = prod_i^D p_i.\n\n\n\n\n\ndegree(H::MonomialBasis) --> Int\n\nReturn the degree M of a monomial basis x^M.\n\nSee also degree(::Monomial).\n\n\n\n\n\ndegree(H::MonomialHamiltonian) --> Int\n\nReturn the degree of the H, i.e., the order or overall exponent of the k-polynomial in H.\n\nSee also degree(::MonomialBasis).\n\n\n\n\n\ndegree(Hs::HamiltonianExpansion) --> Int\n\nReturn the maximum degree of the MonomialHamiltonians contained in Hs.\n\nSee also degree(::MonomialHamiltonian).\n\n\n\n\n\n","category":"function"},{"location":"#KdotP.chern_2x2_hamiltonian","page":"API","title":"KdotP.chern_2x2_hamiltonian","text":"chern_2x2_hamiltonian(\n    d; \n    cartesian::Bool = false,\n    NÎ¸::Int = 31,\n    NÏ†::Int = 51,\n    k_abs::Real = 1e-1)      --> Float64\n\nEvaluate the topological charge, or Chern number, of the lowest band of a 2Ã—2 Hamiltonian H(ð¤) = ð›” â‹… ð(ð¤), expanded on the Pauli matrices ð›” = [Ïƒâ‚, Ïƒâ‚‚, Ïƒâ‚ƒ] and a coefficient vector ð(ð¤) which completely determines Hamiltonian and is given as an input function d. This function must return a 3D vector [dâ‚, dâ‚‚, dâ‚ƒ] for every input ð¤-vector.\n\nThe topological charge is evaluated over a ð¤-space sphere surrounding the origin ð¤ = ðŸŽ. The coefficient vector ð(ð¤) can be provided either in cartesian coordinates, i.e., as  d(kâ‚,kâ‚‚,kâ‚ƒ), or in spherical coordinates, i.e., as d(Î¸, Ï†, |k|) (default); see keyword argument cartesian.\n\nMethod\n\nThe Chern number of the lowest band is evaluated by computing the total solid angle under the manifold Ì‚ð(SÂ²) with SÂ² denoting the 2-sphere divided by 4Ï€, i.e., the degree of the map Ì‚ð. The Chern number of the lowest band is then Câ‚‹ = deg(Ì‚ð)/4Ï€. This is achieved numerically by discretization the 2-sphere on an equidistant grid in the polar and azimuthal angles, and constructing a triangular mesh from each associated cell.\n\nThe Chern number of the highest band is the negated value of the first band's Chern number.\n\nKeyword arguments\n\ncartesian :: Bool (default, false): whether the input function d is provided in cartesian coordinates (true) or in spherical coordinates (false). If provided in cartesian coordinates, the function is internally converted to spherical coordinates.\nNÎ¸ :: Integer (default, 31): number of discretization values of the polar angle.\nNÏ† :: Integer (default, 51): number of discretization values of the azimuthal angle.\nk_abs :: Real (default, 1e-1): ð¤-space radius of the sphere over which the Chern number is evaluated.\n\nExamples\n\nWe may e.g., compute the topological charge of the lowest band in a conventional Weyl Hamiltonian H(ð¤) = ð›” â‹… ð¤:\n\njulia> d(Î¸, Ï†, k) = [k*sin(Î¸)*cos(Ï†), k*sin(Î¸)*sin(Ï†), k*cos(Î¸)]; # d(kâ‚,kâ‚‚,kâ‚ƒ) = [kâ‚,kâ‚‚,kâ‚ƒ]\n\njulia> chern_2x2_hamiltonian(d)\n1.000000000000007\n\nIf the function is only known in cartesian coordinates, it can be provided with the cartesian keyword argument set to true:\n\njulia> d(k1, k2, k3) = [k1,k2,k3];\n\njulia> chern_2x2_hamiltonian(d; cartesian=true)\n1.000000000000007\n\njulia> d(kx, ky, kz) = [kx^3-3kx*ky^2, 3kx^2*ky - ky^3, kz]; # Chern number of 3\n\njulia> chern_2x2_hamiltonian(d; cartesian=true)\n2.9999999999999756\n\n\n\n\n\n","category":"function"}]
}
