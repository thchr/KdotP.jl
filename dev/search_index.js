var documenterSearchIndex = {"docs":
[{"location":"internal-api/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"This page lists unexported functionality from KdotP, that may be of interest to developers.","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"","category":"page"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"CurrentModule = KdotP","category":"page"},{"location":"internal-api/#Unexported,-internal-functionality","page":"Internal API","title":"Unexported, internal functionality","text":"","category":"section"},{"location":"internal-api/","page":"Internal API","title":"Internal API","text":"Modules = [KdotP]\nPrivate = true\nPublic  = false\nOrder   = [:type, :function, :constant]","category":"page"},{"location":"internal-api/#KdotP.minimal_generators_indices-Tuple{Any}","page":"Internal API","title":"KdotP.minimal_generators_indices","text":"Returns a set of indices into group g which generates the group g, i.e., such that\n\nidxs = minimal_generators_indices(g; cntr)\ng′ = generate(g[idxs]; cntr)\n\nwhere g′ ~ g (but may differ by trivial reciprocal lattice vectors in some operations).\n\n\n\n\n\n","category":"method"},{"location":"internal-api/#KdotP.poormans_sparsification-Tuple{Any}","page":"Internal API","title":"KdotP.poormans_sparsification","text":"Poor man's \"matrix sparsification\" via the reduced row echelon form.\n\n\n\n\n\n","category":"method"},{"location":"","page":"API","title":"API","text":"CurrentModule = KdotP","category":"page"},{"location":"#KdotP.jl","page":"API","title":"KdotP.jl","text":"","category":"section"},{"location":"#API","page":"API","title":"API","text":"","category":"section"},{"location":"","page":"API","title":"API","text":"kdotp\nMonomialHamiltonian\nMonomialBasis\nMonomial","category":"page"},{"location":"#KdotP.kdotp","page":"API","title":"KdotP.kdotp","text":"kdotp(lgir::LGIrrep,\n      αβγ=nothing;\n      timereversal::Bool = true,\n      degree::Union{Integer, Nothing} = nothing)  -->  Vector{MonomialHamiltonian}\n\nReturn a basis for the allowed k⋅p Hamiltonians of a small irrep lgir up to linear degree in momentum.\n\nInput arguments\n\nlgir: a small irrep of a little group, provided as an instance of the type LGIrrep. Tables of LGIrreps are accessible from the lgirreps function of Crystalline.jl package.\nαβγ: if the little group associated with lgir has free parameters, i.e., if the k-point is parametrized by free parameters (α, β, γ), these parameters may be set via αβγ = [α, β, γ]. If αβγ = nothing (default), lgir is implicitly evaluated at αβγ = [0, 0, 0].\n\nKeyword arguments\n\ntimereversal (keyword argument): if true (default), time-reversal invariance is imposed on the k⋅p expansion. If lgir is a corepresentation (i.e., a \"glued-up\" irrep), timereversal must be set to true; conversely, if lgir is a pseudoreal or complex irrep that would otherwise pair up under time-reversal, timereversal must be set to false.\ndegree: if provided, monomial terms up to degree will be considered; if degree = nothing (default), the search over monomial terms will terminate after finding the lowest-degree allowed (i.e., nonvanishing) monomial term.\n\nOutput\n\nHs: a vector of MonomialHamiltonian, with each element Hᴹ containing the allowable terms of a k⋅p expansion of incrementing monomial degree degree(Hᴹ) consistent with the transformation properties dictated by lgir.\nEach such allowable term Hᴹ = H^M(mathbfk) is an expansion in a set of basis elements H_a^M(mathbfk):\nH^M(mathbfk) = sum_a q_a H_a^M(mathbfk)\nwhere q_a are free coefficients and H_a^M(mathbfk) are the basis elements of the degree M = degree(Hᴹ) monomial terms of the k⋅p Hamiltonian.\nThe coordinates of the k⋅p model are displayed as x, y, & z for brevity; in practice, they refer to the relative coordinates k₁, k₂, & k₃, respectively, for the k-point k = ∑ᵢkᵢGᵢ, with Gᵢ denoting a reciprocal basis vector. This reciprocal basis is implicitly specified through the choice of coordinates used in  specifying the little group operations associated with lgir.\nTo evaluate Hᴹ for a specific set of expansion vectors at a particular k-point (measured relative to the k-point in lgir, and, as described above, assumed referred to the basis system assumed in lgir) and for a particular set of expansion coefficients qs = q_1 q_2 ldots q_N, Hᴹ can be  called as a functor using the syntax  Hᴹ(k, qs).\n\n\n\n\n\n","category":"function"},{"location":"#KdotP.MonomialHamiltonian","page":"API","title":"KdotP.MonomialHamiltonian","text":"MonomialHamiltonian{D}\n\nFields\n\nhs   :: Vector{Hermitian{ComplexF64, Matrix{ComplexF64}}}\nbᴹ   :: MonomialBasis{D}\ncs   :: Vector{Vector{Vector{Float64}}}\n\nDescription\n\nA MonomialHamiltonian Hᴹ parameterizes the form of a k⋅p Hamiltonian of monomial k-dependence of degree M = degree(Hᴹ):\n\nH^M(mathbfk) = sum_a q_a^M H_a^M(mathbfk)\n\nwhere q_a^M are free (expansion) coefficients and H_a^M(mathbfk) are the basis elements of the allowed k⋅p Hamiltonian terms of monomial degree M.\n\nA MonomialHamiltonian contains the basis elements H_a(mathbfk), allowing only monomial terms of degree M in momentum. In particular, the data structure for the fixed, k-dependent matrices H_a(mathbrmk) are of the form:\n\nH_a(mathbfk) = sum_n H.hs[n] sum_j H.cs[a][j][n] k_j^M\n\nwith H denoting an instance of the type MonomialHamiltonian and k_j^M denoting a basis element of the monomials of degree M (see also KdotP.Monomial and KdotP.MonomialBasis).\n\n\n\n\n\n","category":"type"},{"location":"#KdotP.MonomialBasis","page":"API","title":"KdotP.MonomialBasis","text":"MonomialBasis{D} <: AbstractVector{Monomial}\n\nA wrapper around psv :: Monomial{D}, which jointly form a basis for monomials of degree M.\n\n\n\n\n\n","category":"type"},{"location":"#KdotP.Monomial","page":"API","title":"KdotP.Monomial","text":"Monomial{D}(ps::NTuple{D, Int})\nMonomial(p1, p2, ..., pD)\n\nDefine the D-dimensional monomial xᴹ = x₁^ps[1] … xᵢ^ps[i] … x_D^ps[D] with non-negative integer powers ps. A Monomial xᴹ behaves as a functor and can be evaluated at a given position xs = [x₁, …, xᵢ, …, x_D] via xᴹ(xs).\n\nExamples\n\njulia> xᴹ¹ = Monomial(1,2,3)\nx₁x₂²x₃³\n\njulia> v¹ = xᴹ¹([1,2,3]) # = 1 * 2^2 * 3^3\n108\n\njulia> xᴹ² = Monomial(3,1,0,2)\nx₁³x₂x₄²\n\njulia> v² = xᴹ²([1,2,3,5]) # = 1^3 * 2^1 * 3^0 * 5^2\n50\n\n\n\n\n\n","category":"type"}]
}
